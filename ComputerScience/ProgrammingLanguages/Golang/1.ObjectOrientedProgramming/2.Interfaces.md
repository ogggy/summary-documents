### Interfaces in Go
- An **interface** is a collection of methods that describes the behavior of an object in object-oriented programming languages or of a certain ```type``` — usually a ```struct``` in Go.
- A Go ```interface``` is a type that defines a collection of methods. It's not a value itself, but a box for a value. To use interfaces in the code, we need to have some other type like ```struct``` or an alias to a primitive type in order to implement all the methods from the interface.
- **One-method interfaces** are named by the method name plus an ```-er``` suffix, or a similar modification to construct an agent noun: for example, ```Scanner```, ```Writer```, ```Formatter```.
- Even though it is not obligatory to add the ```-er``` suffix to every interface we create, we should still use meaningful names that appropriately describe the interfaces we create.
```go
package main

import "fmt"

type Speaker struct{}

func (s Speaker) MakeSound() {
    fmt.Println("Boom-Boom! 🔊")
}

type Bell string

func (b Bell) MakeSound() {
    fmt.Println("Ting-Ting! 🔔")
}

type SoundMaker interface {
    MakeSound()
}

func main() {
    var s SoundMaker

    s = Bell("Acme Bell")
    s.MakeSound() // Ting-Ting! 🔔

    s = Speaker{}
    s.MakeSound() // Boom-Boom! 🔊
}
```
- We have the ```Bell``` and the ```Speaker``` types, each having a ```MakeSound()``` method. Since both of these types have the same method signature, we can create the ```SoundMaker``` interface and implement it on both of them.
- We declare ```s``` as a ```SoundMaker``` interface type and assign it to the ```Bell``` and the ```Speaker``` types. Finally, we call the ```MakeSound()``` method on s and see the different “sound” outputs of each type.

---> To implement an ```interface``` properly, the types we create should have all the methods from the interface, with the same signature for each method. Any type that has all the methods listed in an interface definition is said to "satisfy the interface". If the signature for one of the methods differs from the interface, we can't use the type as the given interface.

### Empty interfaces
- An interface that does not specify any methods is an empty interface, and it is represented by the ```interface{}``` syntax. 
- Two important details regarding empty interfaces are that they can hold values of **any type**, and their default value is ```nil```.
```go
...

func describe(i interface{}) {
    fmt.Printf("Value -> %v | Type -> %T\n", i, i)
}

func main() {
    var i interface{}
    describe(i) // Value -> <nil> | Type -> <nil>

    i = 42
    describe(i) // Value -> 42 | Type -> int

    i = "hello"
    describe(i) // Value -> hello | Type -> string
}
```
- An example of a use case of empty interfaces is within the ```fmt.Print()``` family of functions:
```go
func Print(a ...interface{}) (n int, err error)
```

### Use cases of interfaces
- For example, we might want to create an interface that helps us calculate the monthly salary expense generated by different types of employees in a company:
```go
type EmployeeContract struct {
    EmpID         int
    Salary        float64
    TaxPercentage float64
}

type FreelancerContract struct {
    EmpID       int
    HourlyRate  float64
    HoursWorked int
}

// 'EmployeeContract' Salary is the base salary - calculated taxes
func (e EmployeeContract) CalculateSalary() float64 {
    return e.Salary - (e.TaxPercentage * e.Salary)
}

// 'FreelancerContract' salary is the hourly rate * hours worked -- they declare taxes themselves
func (f FreelancerContract) CalculateSalary() float64 {
    return f.HourlyRate * float64(f.HoursWorked)
}

type SalaryCalculator interface {
    CalculateSalary() float64
}
```
After creating the two different types of employee contracts, we can use the ```SalaryCalculator``` interface within the ```main()``` function of our program:
```go
...

func main() {
    homer := EmployeeContract{EmpID: 1, Salary: 479.60, TaxPercentage: 0.245}
    fmt.Printf("Homer's salary: $%.2f\n", homer.CalculateSalary()) // Homer's salary: $362.10

    deadpool := FreelancerContract{EmpID: 2, HourlyRate: 50_000.00, HoursWorked: 10}
    fmt.Printf("Deadpool's salary: $%.2f\n", deadpool.CalculateSalary()) // Deadpool's salary: $500000.00

    employees := []SalaryCalculator{homer, deadpool}
    fmt.Printf("Monthly sal. expense: $%.2f\n", salaryExpense(employees)) // Monthly sal. expense: "$500362.10
}

// salaryExpense() takes a slice of []SalaryCalculator and returns the sum of all salaries
func salaryExpense(salaries []SalaryCalculator) float64 {
    totalExpense := 0.0
    for _, v := range salaries {
        totalExpense += v.CalculateSalary()
    }
    return totalExpense
}
```
---> Since the ```salaryExpense()``` function takes the slice employees of the ```SalaryCalculator``` interface as an argument; we can pass in **any type** of employee contract as long as they implement the ```SalaryCalculator``` interface!


